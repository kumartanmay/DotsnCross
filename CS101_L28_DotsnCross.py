# THREE GOLD STARS
# Question 3-star: Elementary Cellular Automaton

# Please see the video for additional explanation.

# A one-dimensional cellular automata takes in a string, which in our
# case, consists of the characters '.' and 'x', and changes it according
# to some predetermined rules. The rules consider three characters, which
# are a character at position k and its two neighbours, and determine
# what the character at the corresponding position k will be in the new
# string.

# For example, if the character at position k in the string  is '.' and
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up
# '..x' in the table below. In the table, '..x' corresponds to 'x' which
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                           142

# To calculate the patterns which will have the central character x, work
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs:
#     a non-empty string,
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and
#     a positive integer, n, which is the number of generations.
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

rules = {
         1:  ['...', '.'],
         2:  ['..x', 'x'],
         4:  ['.x.', 'x'],
         8:  ['.xx', 'x'],
         16: ['x..', '.'],
         32: ['x.x', '.'],
         64: ['xx.', '.'],
         128:['xxx', 'x']
         }

def cellular_automaton(string, pattern_num, gen_num):

    pattern_keys = pattern(pattern_num)
    #print pattern_keys

    #changing the rules
    #changing pattern keys to 'x'
    for keys in pattern_keys:
        val = rules[keys]
        val[-1] = 'x'

    rules_keys = rules.keys()

    #changing rest of the keys to '.'
    for elements in rules_keys:
        if elements not in pattern_keys:
            val = rules[elements]
            val[-1] = '.'
    dict_values = rules.values()

    #reading the string
    target_string = None
    #print len(dict_values)
    #print dict_values[3][0]

    for k in range(gen_num):
        result = ''
        for i in range(0, len(string)):
            #defining the triplets of target string
            if i == 0 and i+1 < len(string):
                target_string = string[-1] + string[i] + string[i+1]
            elif i == len(string) - 1:
                target_string = string[i-1] + string[i] + string[0]
            else:
                target_string = string[i-1] + string[i] + string[i+1]

            for a in range(len(dict_values)):
                #for b in range(0,2): # length of each value in dictionary is 2
                if target_string in dict_values[a][0]:
                    result = result + dict_values[a][1]
        string = result
    return result

def pattern(pattern_num):
    #return the rule numbers
    if pattern_num < 256 and pattern_num > 0:
    #creating a list of all keys less than pattern number
        key_list = rules.keys()
        pattern = []
        for items in key_list:
            if items <= pattern_num:
                pattern.append(items)
        pattern.sort()
        #print pattern

        if pattern:
            num_set = pattern[-1]
            central = [pattern[-1]] #keys that add up to pattern number
        #comparing number with the largest first
            node = len(pattern) - 2 #starting with the second last element
            while node >= 0:
                if num_set + pattern[node] <= pattern_num:
                    central.append(pattern[node])
                    num_set = num_set + pattern[node]
                node = node - 1
            return central
        else:
            return rules.keys()
    else:
        return []


print cellular_automaton('.x.x.x.x.', 17, 2)
#>>> xxxxxxx..
print cellular_automaton('.x.x.x.x.', 249, 3)
#>>> .x..x.x.x
print cellular_automaton('...x....', 125, 1)
#>>> xx.xxxxx
print cellular_automaton('...x....', 125, 2)
#>>> .xxx....
print cellular_automaton('...x....', 125, 3)
#>>> .x.xxxxx
print cellular_automaton('...x....', 125, 4)
#>>> xxxx...x
print cellular_automaton('...x....', 125, 5)
#>>> ...xxx.x
print cellular_automaton('...x....', 125, 6)
#>>> xx.x.xxx
print cellular_automaton('...x....', 125, 7)
#>>> .xxxxx..
print cellular_automaton('...x....', 125, 8)
#>>> .x...xxx
print cellular_automaton('...x....', 125, 9)
#>>> xxxx.x.x
print cellular_automaton('...x....', 125, 10)
#>>> ...xxxxx
print cellular_automaton('...x....', 0, 1)
print cellular_automaton('.', 21, 5)
print cellular_automaton('...x....', 1, 6)
